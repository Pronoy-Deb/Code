#include <iostream>
#include <stack>
#include <string>
#include <unordered_map>
#include <vector>
#include <cctype> // for isupper()

using namespace std;

// Simulated parsing table as a nested map
unordered_map<char, unordered_map<char, string>> parsingTable;

// Function to initialize the parsing table
void initializeParsingTable() {
    // Example: Add production rules to the parsing table
    parsingTable['S']['a'] = "AB";
    parsingTable['A']['a'] = "a";
    parsingTable['B']['b'] = "b";
    parsingTable['B']['$'] = "#"; // Assume '#' represents epsilon
    // Add more rules as necessary
}

void parseString(const string& input) {
    stack<char> parserStack;
    parserStack.push('$'); // End marker
    parserStack.push('S'); // Start symbol

    string inputString = input + "$"; // Add end marker to input

    size_t inputIndex = 0;
    while (!parserStack.empty()) {
        char A = parserStack.top(); // Top symbol of the stack
        char r = inputString[inputIndex]; // Next input symbol

        if (islower(A) || A == '$') { // A is terminal or $
            if (A == r) { // Match
                parserStack.pop();
                inputIndex++; // Consume input symbol
            } else {
                cout << "ERROR: Mismatched terminal '" << A << "' and input '" << r << "'\n";
                return;
            }
        } else if (isupper(A)) { // A is a non-terminal
            if (parsingTable[A].count(r) && parsingTable[A][r] != "error") {
                parserStack.pop(); // Pop non-terminal

                string production = parsingTable[A][r];
                if (production != "#") { // Push the production in reverse order
                    for (auto it = production.rbegin(); it != production.rend(); ++it) {
                        parserStack.push(*it);
                    }
                }
            } else {
                cout << "ERROR: No valid production for non-terminal '" << A << "' with input '" << r << "'\n";
                return;
            }
        }
    }

    // If parsing is successful
    if (inputIndex == inputString.size()) {
        cout << "SUCCESS: The input string is generated by the grammar.\n";
    } else {
        cout << "ERROR: Input string was not completely consumed.\n";
    }
}

int main() {
    initializeParsingTable();

    string input;
    cout << "Enter the input string: ";
    cin >> input;

    parseString(input);

    return 0;
}
